@inject Manager manager
@rendermode InteractiveServer

<div>
    @foreach (TaskItem taskItem in IncompleteParentTaskItems)
    {
        <div @onclick="() => ParentTaskSelected(taskItem)">
            <TaskRow InputTask=taskItem OnTaskUpdated="HandleTaskUpdate" AllEmployees="@AllEmployees" OnTaskSelected="TaskSelected" />
            <div>

                @if (SubTaskItems.ContainsKey(taskItem.TaskId))
                {
                    <div class="@(SelectedParentTaskId == taskItem.TaskId ? showCollapsible : hideCollapsible)">
                        @foreach (TaskItem subTaskItem in SubTaskItems[taskItem.TaskId].OrderBy(asc => asc.IsCompleted))
                        {
                            <div>
                                <TaskRow InputTask=subTaskItem OnTaskUpdated="HandleTaskUpdate" AllEmployees="@AllEmployees" OnTaskSelected="TaskSelected" />
                            </div>
                        }
                    </div>
                }
                @if (SelectedParentTaskId == taskItem.TaskId)
                {
                    <NewTask ProjectId=CurrentProject.ProjectId ParentTaskId=taskItem.TaskId OnTaskAdded="HandleTaskAdded" AllActiveEmployees="AllEmployees" />
                    <hr />
                }
            </div>
        </div>
    }
</div>
@if(CompleteParentTaskItems.Count > 0)
{
    <br />
    <hr />
    <br />
}
<div>
    @foreach (TaskItem taskItem in CompleteParentTaskItems)
    {
        <div @onclick="() => ParentTaskSelected(taskItem)">
            <TaskRow InputTask=taskItem OnTaskUpdated="HandleTaskUpdate" AllEmployees="@AllEmployees" OnTaskSelected="TaskSelected" />
            <div>

                @if (SubTaskItems.ContainsKey(taskItem.TaskId))
                {
                    <div class="@(SelectedParentTaskId == taskItem.TaskId ? showCollapsible : hideCollapsible)">
                        @foreach (TaskItem subTaskItem in SubTaskItems[taskItem.TaskId].OrderBy(asc => asc.IsCompleted))
                        {
                            <div>
                                <TaskRow InputTask=subTaskItem OnTaskUpdated="HandleTaskUpdate" AllEmployees="@AllEmployees" OnTaskSelected="TaskSelected" />
                            </div>
                        }
                    </div>
                }
                @if (SelectedParentTaskId == taskItem.TaskId)
                {
                    <NewTask ProjectId=CurrentProject.ProjectId ParentTaskId=taskItem.TaskId OnTaskAdded="HandleTaskAdded" AllActiveEmployees="AllEmployees" />
                }
            </div>
        </div>
    }
</div>

@code {
    [Parameter]
    public EventCallback<TaskItem> OnTaskSelected { get; set; }

    [Parameter]
    public EventCallback OnTaskUpdated { get; set; }

    [Parameter]
    public required Project CurrentProject { get; set; }

    [Parameter]
    public bool ShowIncompleteOnly { get; set; } = false;

    private List<TaskItem> IncompleteParentTaskItems { get; set; } = [];
    private List<TaskItem> CompleteParentTaskItems { get; set; } = [];

    private Dictionary<int, List<TaskItem>> SubTaskItems { get; set; } = [];
    private List<Employee> AllEmployees => manager.EmployeeDB.AllActive;

    [Parameter]
    public int SelectedParentTaskId { get; set; } = 0;

    string showCollapsible = "content-show";
    string hideCollapsible = "content-hidden";


    protected override void OnInitialized()
    {
        manager.EmployeeDB.PropertyChanged += (_, __) => InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        manager.EmployeeDB.PropertyChanged -= (_, __) => InvokeAsync(StateHasChanged);
    }

    protected override async Task OnParametersSetAsync()
    {
        await RefreshTasks();
        base.OnParametersSet();
    }

    private async Task RefreshTasks()
    {
        IncompleteParentTaskItems = await manager.TaskItemDB.GetAllIncompleteParentTasks(CurrentProject.ProjectId);

        if (!ShowIncompleteOnly)
        {
            CompleteParentTaskItems = await manager.TaskItemDB.GetAllCompleteParentTasks(CurrentProject.ProjectId);
        }

        SubTaskItems = [];
        Dictionary<int, List<TaskItem>> subTaskTemp = manager.TaskItemDB.GetAllSubTasks(CurrentProject.ProjectId).Result;
        foreach (KeyValuePair<int, List<TaskItem>> subTask in subTaskTemp)
        {
            if (!SubTaskItems.ContainsKey(subTask.Key))
            {
                SubTaskItems[subTask.Key] = new List<TaskItem>();
            }
            SubTaskItems[subTask.Key].AddRange(subTask.Value);
        }
        StateHasChanged();
    }

    void ParentTaskSelected(TaskItem task)
    {
        SelectedParentTaskId = task.TaskId;
    }

    async void TaskSelected(TaskItem task)
    {
        await OnTaskSelected.InvokeAsync(task);
    }

    async void HandleTaskUpdate()
    {
        await RefreshTasks();
        await OnTaskUpdated.InvokeAsync();
    }

    async void HandleTaskAdded(TaskItem task)
    {
        task.ProjectId = CurrentProject.ProjectId;
        await manager.TaskItemDB.InsertAsync(task);
        if (task.ParentTaskId == 0)
        {
            SelectedParentTaskId = 0;
        }
        await RefreshTasks();
    }

    private async void HandleToggleShowComplete(bool showIncomplete)
    {
        ShowIncompleteOnly = !showIncomplete;
        await RefreshTasks();
    }
}
